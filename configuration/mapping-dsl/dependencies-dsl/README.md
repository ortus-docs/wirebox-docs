# Dependencies DSL

The dependencies DSL methods are mostly used to define dependencies and also to activate advanced features on target objects, such as runtime mixins, virtual inheritance, etc.

> **Note** Please note that you can concatenate more than one of these methods calls to dictate multiple constructor arguments, setter methods, cf properties, and more.

| Method Signature                                          | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| --------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `constructor(constructor)`                                | Tells WireBox which constructor to call on the mapped object. By default if an object has an `init()` method, that will be used as the constructor                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| `noInit()`                                                | Tells WireBox that this mapped object will skip the constructor call for it. By default WireBox always calls object constructors                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| `threadSafe()`                                            | Tells WireBox that the mapped object should be constructed and then wired with a strict concurrency lock for property injections, setter injections and onDIComplete(). Please be aware that if you use this mode of construction, circular dependencies are not allowed. The default is that property and setter injections and onDIComplete() are outside of the construction locks                                                                                                                                                                                                                                                                                                                                                                                                                             |
| `notThreadSafe()`                                         | Tells WireBox to construct objects by locking only the constructor and constructor argument dependencies to allow for circular dependencies. This is the default construction mode of all persisted objects: singleton, session, server, application and cachebox scope                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| `noAutowire()`                                            | Tells WireBox that this mapped object has its dependencies described programmatically instead of using metadata inspection to discover them                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| `parent(alias)`                                           | Tells WireBox that this mapped object has a parent mapping with definitions it should use to base it from. This feature provides a great way to reuse object mapping definitions                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| `initArg([name],[ref],[dsl],[value],[javaCast])`          | <p>Used to define a constructor argument for the mapped object.<br><br><code>name</code> : The name of the constructor argument. Not used for Java or Webservice construction<br><code>ref</code> : The mapping reference id this constructor is mapped to. E.G. ref='MyFunkyEspresso'<br><code>dsl</code> : The construction dsl that will be used to construct this constructor argument<br><code>value</code> : The constant value you can use instead of a dsl or ref for this constructor argument<br><code>javaCast</code> : If using a java object, you can cast the value of this constructor argument</p>                                                                                                                                                                                                |
| `initWith()`                                              | You can pass as many arguments (named or positional) to this method to simulate the `init()` call of the mapped object. WireBox will then use that argument collection to initialize the mapped object. Note, `initWith()` only accepts arguments which can be evaluated at the time the binder is parsed such as static values, or binder properties. To specify mapping IDs or DSLs, use \`initArg()                                                                                                                                                                                                                                                                                                                                                                                                            |
| `methodArg([name],[ref],[dsl],[value],[javaCast])`        | <p>Used to define a factory method argument for the mapped object when using a factory method construction.<br><br><code>name</code> : The name of the method argument. Not used for Java or Webservice construction<br><code>ref</code> : The mapping reference id this method argument is mapped to. E.G. ref='MyFunkyEspresso'<br><code>dsl</code> : The construction dsl that will be used to construct this method argument<br><code>value</code> : The constant value you can use instead of a dsl or ref for this method argument<br><code>javaCast</code> : If using a java object, you can cast the value of this method argument</p>                                                                                                                                                                    |
| `property([name],[ref],[dsl],[value],[javaCast],[scope])` | <p>Used to define a property mixin that will occur at runtime.<br><br><code>name</code> : The name of the property value to inject. Not used for Java or Webservice construction<br><code>ref</code> : The mapping reference id this property is mapped to. E.G. ref='MyFunkyEspresso'<br><code>dsl</code> : The construction dsl that will be used to construct this property argument<br><code>value</code> : The constant value you can use instead of a dsl or ref for this property argument<br><code>javaCast</code> : If using a java object, you can cast the value of this property argument<br><code>scope</code> : The scope inside the CFC this property will be injected too. The default scope is the <code>variables</code> scope.</p>                                                             |
| `setter([name],[ref],[dsl],[value],[javaCast],[argName])` | <p>Used to define all the setter dependencies for a mapped object that follows the JavaBean spec: <code>setXXX</code> where <code>XXX</code> is the name of the mapped object.<br><br><code>name</code> : The name of the setter. Not used for Java or Webservice construction<br><code>ref</code> : The mapping reference id this setter is mapped to. E.G. ref='MyFunkyEspresso'<br><code>dsl</code> : The construction dsl that will be used to construct this setter dependency<br><code>value</code> : The constant value you can use instead of a dsl or ref for this setter dependency<br><code>javaCast</code> : If using a java object, you can cast the value of this setter dependency<br><code>argName</code> : The name of the argument to use, if not passed, we default it to the setter name.</p> |
| `mixins(udfIncludeList)`                                  | A UDF template, a list of templates or an array of templates that WireBox should use to mix-in into the target object. It will take all the methods defined in those UDF templates and mixed them into the target object at runtime.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| `providerMethod(method,mapping)`                          | Will inject a new method or override a method on the target object with a new method that provides objects of the mapping you specify.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| `virtualInheritance(Mapping)`                             | Create a runtime virtual inheritance from a target object into a target mapping. This approach blends the CFCs together at runtime via mixins and WireBox Funkyness!                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| `extraAttributes(struct)`                                 | Allows the ability to store extra metadata about a mapping into WireBox that can later be retrieved via AOP invocations or WireBox events.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| `withInfluence( closure/UDF )`                            | Influence the creation process of a single object. The instance is already built and then passed into the closure for additional influence. You can optionally return the object and it will override it.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
